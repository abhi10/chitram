name: CD

on:
  push:
    branches: [main]
  workflow_dispatch:  # Allow manual trigger

env:
  PYTHON_VERSION: "3.11"

jobs:
  # ============================================
  # Step 1: Run full test suite before deployment
  # ============================================
  test:
    name: Pre-Deploy Tests
    runs-on: ubuntu-latest

    services:
      postgres:
        image: postgres:16
        env:
          POSTGRES_USER: app
          POSTGRES_PASSWORD: localdev
          POSTGRES_DB: imagehost
        ports:
          - 5432:5432
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

      redis:
        image: redis:7-alpine
        ports:
          - 6379:6379
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

    env:
      DATABASE_URL: postgresql+asyncpg://app:localdev@localhost:5432/imagehost
      STORAGE_BACKEND: minio
      MINIO_ENDPOINT: localhost:9000
      MINIO_ACCESS_KEY: minioadmin
      MINIO_SECRET_KEY: minioadmin
      MINIO_BUCKET: images
      MINIO_SECURE: "false"
      REDIS_HOST: localhost
      REDIS_PORT: 6379
      CACHE_ENABLED: "true"

    steps:
      - uses: actions/checkout@v4

      - name: Start MinIO
        run: |
          docker run -d --name minio \
            -p 9000:9000 \
            -e MINIO_ROOT_USER=minioadmin \
            -e MINIO_ROOT_PASSWORD=minioadmin \
            minio/minio:latest server /data

          # Wait for MinIO to be ready
          for i in {1..30}; do
            if curl -sf http://localhost:9000/minio/health/live; then
              echo "MinIO is ready"
              break
            fi
            echo "Waiting for MinIO... ($i/30)"
            sleep 2
          done

      - name: Install uv
        uses: astral-sh/setup-uv@v4
        with:
          version: "latest"

      - name: Set up Python
        run: uv python install ${{ env.PYTHON_VERSION }}

      - name: Install dependencies
        working-directory: backend
        run: uv sync --all-extras

      - name: Create MinIO bucket
        working-directory: backend
        run: |
          uv run python -c "
          from minio import Minio
          client = Minio('localhost:9000', access_key='minioadmin', secret_key='minioadmin', secure=False)
          if not client.bucket_exists('images'):
              client.make_bucket('images')
              print('Created bucket: images')
          "

      - name: Run database migrations
        working-directory: backend
        run: uv run alembic upgrade head

      - name: Run tests
        working-directory: backend
        run: uv run python -m pytest -v --tb=short

  # ============================================
  # Step 2: Build and verify Docker image
  # ============================================
  build:
    name: Build Docker Image
    runs-on: ubuntu-latest
    needs: test

    steps:
      - uses: actions/checkout@v4

      - name: Build Docker image
        working-directory: backend
        run: |
          docker build -t chitram:${{ github.sha }} .
          docker tag chitram:${{ github.sha }} chitram:latest

      - name: Verify image runs
        run: |
          # Start PostgreSQL for testing (production uses PostgreSQL, not SQLite)
          docker run -d --name test-postgres \
            -e POSTGRES_USER=test \
            -e POSTGRES_PASSWORD=test \
            -e POSTGRES_DB=test \
            -p 5432:5432 \
            postgres:16-alpine

          # Wait for PostgreSQL to be ready
          for i in {1..30}; do
            if docker exec test-postgres pg_isready -U test; then
              echo "PostgreSQL is ready"
              break
            fi
            echo "Waiting for PostgreSQL... ($i/30)"
            sleep 2
          done

          # Start the app with PostgreSQL
          docker run -d --name test-app \
            --link test-postgres:postgres \
            -e DATABASE_URL=postgresql+asyncpg://test:test@postgres:5432/test \
            -e STORAGE_BACKEND=local \
            -e LOCAL_STORAGE_PATH=/tmp/uploads \
            -e JWT_SECRET_KEY=test-secret-key \
            -p 8000:8000 \
            chitram:latest

          # Wait for startup
          sleep 15

          # Check if container is still running
          if docker ps | grep -q test-app; then
            echo "Container started successfully"
            docker logs test-app
          else
            echo "Container failed to start"
            docker logs test-app
            docker stop test-postgres || true
            exit 1
          fi

          docker stop test-app
          docker stop test-postgres

  # ============================================
  # Step 3: Deploy to production server
  # ============================================
  deploy:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: [test, build]
    environment: production  # Requires approval if configured

    steps:
      - uses: actions/checkout@v4

      - name: Create deployment package
        run: |
          # Create a deployment archive with required files
          tar -czvf deploy-package.tar.gz \
            backend/ \
            deploy/docker-compose.yml \
            deploy/docker-compose.local.yml \
            deploy/Caddyfile

      - name: Copy files to server
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets.DROPLET_HOST }}
          username: ${{ secrets.DROPLET_USER }}
          key: ${{ secrets.DROPLET_SSH_KEY }}
          source: "deploy-package.tar.gz"
          target: "/tmp"

      - name: Deploy on server
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.DROPLET_HOST }}
          username: ${{ secrets.DROPLET_USER }}
          key: ${{ secrets.DROPLET_SSH_KEY }}
          script: |
            set -e

            # Configuration
            DEPLOY_DIR="/opt/chitram"
            BACKUP_DIR="/opt/chitram-backup-$(date +%Y%m%d-%H%M%S)"

            echo "=== Starting deployment ==="

            # Backup current deployment
            if [ -d "$DEPLOY_DIR" ]; then
              echo "Backing up current deployment to $BACKUP_DIR"
              sudo cp -r "$DEPLOY_DIR" "$BACKUP_DIR"
            fi

            # Extract new deployment
            echo "Extracting deployment package..."
            sudo mkdir -p "$DEPLOY_DIR"
            cd "$DEPLOY_DIR"
            sudo tar -xzf /tmp/deploy-package.tar.gz --strip-components=0

            # Ensure .env.production exists
            if [ ! -f "$DEPLOY_DIR/deploy/.env.production" ]; then
              echo "ERROR: .env.production not found. Please create it manually first."
              exit 1
            fi

            # Deploy with docker compose
            echo "Starting services..."
            cd "$DEPLOY_DIR/deploy"
            sudo docker compose --env-file .env.production pull || true
            sudo docker compose --env-file .env.production build
            sudo docker compose --env-file .env.production up -d

            # Wait for health check (port 80 via Caddy, not 8000)
            echo "Waiting for health check..."
            for i in {1..30}; do
              if curl -sf http://localhost/health > /dev/null 2>&1; then
                echo "Health check passed!"
                break
              fi
              echo "Waiting... ($i/30)"
              sleep 5
            done

            # Verify deployment
            if curl -sf http://localhost/health > /dev/null 2>&1; then
              echo "=== Deployment successful ==="
              # Clean up old backups (keep last 3)
              ls -dt /opt/chitram-backup-* 2>/dev/null | tail -n +4 | xargs -r sudo rm -rf
              rm -f /tmp/deploy-package.tar.gz
            else
              echo "=== Deployment failed, rolling back ==="
              if [ -d "$BACKUP_DIR" ]; then
                sudo rm -rf "$DEPLOY_DIR"
                sudo mv "$BACKUP_DIR" "$DEPLOY_DIR"
                cd "$DEPLOY_DIR/deploy"
                sudo docker compose --env-file .env.production up -d
              fi
              exit 1
            fi

      - name: Verify production health
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.DROPLET_HOST }}
          username: ${{ secrets.DROPLET_USER }}
          key: ${{ secrets.DROPLET_SSH_KEY }}
          script: |
            # Final health verification (port 80 via Caddy)
            echo "=== Production Health Check ==="
            curl -s http://localhost/health | jq . || curl -s http://localhost/health

            # Show running containers
            echo ""
            echo "=== Running Containers ==="
            docker ps --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"
